const webpack = require('webpack');
const path = require('path');
const fs = require('fs');
const devMiddleware = require('webpack-dev-middleware');
const hotMiddleware = require('webpack-hot-middleware');
const clientConfig = require('../build/webpack.dev.client');
const serverConfig = require('../build/webpack.server.js');
const dashboardConfig = require('../build/webpack.dashboard.dev.js');
const MemoryFileSystem = require('memory-fs');
const chalk = require('chalk');
const chokidar = require('chokidar');

const readBuildFile = (fs, filePath) => {
    try {
        return fs.readFileSync(filePath, 'utf-8')
    } catch (e) {
        console.log(e);
    }
}


module.exports = function devServer (app, templatePath, updateBundleRenderer) {
    let readyResolve;
    let readyPromise = new Promise(resolve => {
        readyResolve = resolve;
    })
    let serverBundle;
    const renderOption = {
        runInNewContext: false
    };

    update = () => {
        if (serverBundle) {
            readyResolve();
            updateBundleRenderer(serverBundle, {
                runInNewContext: false,
                template,
                clientManifest,
                shouldPreload: (file, type) => {
                    if (type === 'script') {
                        return true;
                    } else {
                        return false;
                    }
                },
                shouldPrefetch: (file, type) => {
                    return false
                }
            });
        }
    }

    // client bundle hot-reload
    const clientComplier = webpack(clientConfig);

    const devMiddlewareServer = devMiddleware(clientComplier, {
        // webpack 将静态资源输出到dev middleware里面的内存文件系统
        // 将静态资源服务映射到 dev middleware 内存文件系统
        publicPath: clientConfig.output.publicPath,
        quiet: true
    });
    app.use(devMiddlewareServer);

    clientComplier.plugin('done', stats => {
        stats = stats.toJson()
        stats.errors.forEach(err => console.error(err))
        stats.warnings.forEach(err => console.warn(err))
        if (stats.errors.length) return
        // console.log(devMiddlewareServer.fileSystem.data.Users.ecizep.project.github.myblog.static.dist);
        clientManifest = JSON.parse(readBuildFile(devMiddlewareServer.fileSystem, path.join(clientConfig.output.path, 'vue-ssr-client-manifest.json')))
        console.log(chalk.green('[ webpack.dev.config.js ]: client complile done'));
        update();
    })

    app.use(hotMiddleware(clientComplier, {
        // 需要和clientConfig里面的path保持一致
        path: '/__client_hmr',
        heartbeat: 2000
    }));

    // dashboard bundle hot-reload
    const dashboardComplier = webpack(dashboardConfig);

    app.use(devMiddleware(dashboardComplier, {
        publicPath: dashboardConfig.output.publicPath,
        quiet: true
    }));

    app.use(hotMiddleware(dashboardComplier, {
        // 保持一致
        path: '/__dashboard_hmr',
        heartbeat: 2000
    }));


    // server bundle hot-reload
    const serverComplier = webpack(serverConfig);
    const mfs = new MemoryFileSystem();
    serverComplier.outputFileSystem = mfs;
    serverComplier.watch({}, (err, stats) => {
        if (err) throw err;
        stats = stats.toJson();
        if (stats.errors.length) return;
        console.log(chalk.green('[ webpack.server.js ]: server bundle update'));
        // read bundle generated by vue-ssr-webpack-plugin
        serverBundle = JSON.parse(readBuildFile(mfs, path.join(serverConfig.output.path, 'vue-ssr-server-bundle.json')))
        update();
    });

    // template hot-reload
    let template = fs.readFileSync(templatePath, 'utf-8');
    chokidar.watch(templatePath).on('change', () => {
        template = fs.readFileSync(templatePath, 'utf-8');
        console.log(chalk.green('[ chokidar watch ]: index.template.html updated'));
        update();
    })


    return readyPromise;
}